#!/bin/bash
#
# Generate TypeScript API Client from OpenAPI Specification
#
# This script generates a fully typed TypeScript client from the OpenAPI spec.
# The generated client includes:
# - Type-safe request/response models
# - All endpoint methods
# - Proper error handling
# - Request/response interceptors support
#
# Usage:
#   ./scripts/generate-api-client.sh
#
# Requirements:
#   - Node.js 18+
#   - pnpm installed
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
FRONTEND_DIR="$PROJECT_ROOT/frontend"
SPECS_DIR="$PROJECT_ROOT/specs"
OUTPUT_DIR="$FRONTEND_DIR/src/lib/api/generated"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if openapi-typescript is installed
check_dependencies() {
    log_info "Checking dependencies..."

    if ! command -v pnpm &> /dev/null; then
        log_error "pnpm is not installed. Please install it first."
        exit 1
    fi

    cd "$FRONTEND_DIR"

    # Check if openapi-typescript is in devDependencies
    if ! pnpm list openapi-typescript 2>/dev/null | grep -q openapi-typescript; then
        log_warn "openapi-typescript not found. Installing..."
        pnpm add -D openapi-typescript openapi-fetch
    fi
}

# Generate TypeScript types from OpenAPI spec
generate_types() {
    log_info "Generating TypeScript types from OpenAPI spec..."

    mkdir -p "$OUTPUT_DIR"

    cd "$FRONTEND_DIR"

    # Generate types using openapi-typescript
    pnpm exec openapi-typescript "$SPECS_DIR/openapi.yaml" \
        --output "$OUTPUT_DIR/schema.ts" \
        --export-type \
        --immutable

    log_info "Generated: $OUTPUT_DIR/schema.ts"
}

# Generate API client wrapper
generate_client() {
    log_info "Generating API client wrapper..."

    cat > "$OUTPUT_DIR/client.ts" << 'EOF'
/**
 * Generated API Client
 *
 * This file provides a type-safe client for the OHPM API.
 * It wraps openapi-fetch with proper authentication and error handling.
 *
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-api-client.sh
 */

import createClient from 'openapi-fetch';
import type { paths, components } from './schema';

// Re-export types for convenience
export type { paths, components };

// Extract common types
export type AuthTokensResponse = components['schemas']['AuthTokensResponse'];
export type UserResponse = components['schemas']['UserResponse'];
export type Task = components['schemas']['Task'];
export type Annotation = components['schemas']['Annotation'];
export type QualityMetrics = components['schemas']['QualityMetrics'];
export type Metric = components['schemas']['Metric'];
export type Alert = components['schemas']['Alert'];
export type RecalibrationRequest = components['schemas']['RecalibrationRequest'];
export type RecalibrationResponse = components['schemas']['RecalibrationResponse'];
export type ProblemDetail = components['schemas']['ProblemDetail'];
export type WebSocketMessage = components['schemas']['WebSocketMessage'];
export type FederatedStatus = components['schemas']['FederatedStatus'];
export type RoundDetails = components['schemas']['RoundDetails'];
export type ClientParticipation = components['schemas']['ClientParticipation'];
export type ALConfig = components['schemas']['ALConfig'];
export type ALStatus = components['schemas']['ALStatus'];
export type QueueItem = components['schemas']['QueueItem'];

// Client configuration
interface ClientConfig {
  baseUrl: string;
  getAccessToken?: () => string | null;
  onUnauthorized?: () => void;
}

// Create typed API client
export function createApiClient(config: ClientConfig) {
  const client = createClient<paths>({
    baseUrl: config.baseUrl,
  });

  // Add auth interceptor
  client.use({
    onRequest: ({ request }) => {
      const token = config.getAccessToken?.();
      if (token) {
        request.headers.set('Authorization', `Bearer ${token}`);
      }
      return request;
    },
    onResponse: ({ response }) => {
      if (response.status === 401) {
        config.onUnauthorized?.();
      }
      return response;
    },
  });

  return {
    // Auth endpoints
    auth: {
      register: (body: components['schemas']['RegisterRequest']) =>
        client.POST('/api/auth/register', { body }),

      login: (body: components['schemas']['LoginRequest']) =>
        client.POST('/api/auth/login', { body }),

      refresh: (body: components['schemas']['RefreshRequest']) =>
        client.POST('/api/auth/refresh', { body }),

      logout: (body: components['schemas']['RefreshRequest']) =>
        client.POST('/api/auth/logout', { body }),

      me: () =>
        client.GET('/api/auth/me'),
    },

    // Task endpoints
    tasks: {
      getNext: (annotatorId: string) =>
        client.GET('/api/tasks/next', {
          params: { query: { annotator_id: annotatorId } },
        }),
    },

    // Annotation endpoints
    annotations: {
      list: (params?: {
        annotator_id?: string;
        task_id?: string;
        page?: number;
        page_size?: number;
      }) =>
        client.GET('/api/annotations', {
          params: { query: params },
        }),

      submit: (body: components['schemas']['Annotation']) =>
        client.POST('/api/annotations', { body }),
    },

    // Quality endpoints
    quality: {
      getMetrics: (annotatorId: string) =>
        client.GET('/api/quality/metrics', {
          params: { query: { annotator_id: annotatorId } },
        }),
    },

    // Calibration endpoints
    calibration: {
      recalibrate: (body: components['schemas']['RecalibrationRequest']) =>
        client.POST('/api/calibration/recalibrate', { body }),

      recordPrediction: (body: components['schemas']['PredictionRecordRequest']) =>
        client.POST('/api/calibration/predictions', { body }),
    },

    // Monitoring endpoints
    monitoring: {
      getMetrics: (name: string) =>
        client.GET('/api/metrics', {
          params: { query: { name } },
        }),

      getAlerts: () =>
        client.GET('/api/alerts'),

      acknowledgeAlert: (alertId: string) =>
        client.POST('/api/alerts/{alert_id}/ack', {
          params: { path: { alert_id: alertId } },
        }),

      getWebSocketStats: () =>
        client.GET('/api/ws/stats'),
    },

    // Health check
    health: {
      check: () =>
        client.GET('/api/health'),
    },

    // Federated Learning endpoints
    federated: {
      getStatus: () => client.GET('/api/federated/status'),
      getRounds: () => client.GET('/api/federated/rounds'),
      getClients: () => client.GET('/api/federated/clients'),
      startRound: () => client.POST('/api/federated/start'),
      pauseTraining: () => client.POST('/api/federated/pause'),
    },

    // Active Learning endpoints
    activeLearning: {
      getConfig: () => client.GET('/api/active-learning/config'),
      updateConfig: (body: components['schemas']['ALConfig']) => 
        client.PATCH('/api/active-learning/config', { body }),
      getStatus: () => client.GET('/api/active-learning/status'),
      getQueue: () => client.GET('/api/active-learning/queue'),
      refresh: () => client.POST('/api/active-learning/refresh'),
    },

    // Raw client for advanced usage
    raw: client,
  };
}

// Default client instance
let defaultClient: ReturnType<typeof createApiClient> | null = null;

export function getApiClient(): ReturnType<typeof createApiClient> {
  if (!defaultClient) {
    throw new Error(
      'API client not initialized. Call initializeApiClient() first.'
    );
  }
  return defaultClient;
}

export function initializeApiClient(config: ClientConfig): ReturnType<typeof createApiClient> {
  defaultClient = createApiClient(config);
  return defaultClient;
}
EOF

    log_info "Generated: $OUTPUT_DIR/client.ts"
}

# Generate index file
generate_index() {
    log_info "Generating index file..."

    cat > "$OUTPUT_DIR/index.ts" << 'EOF'
/**
 * Generated API Module
 *
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-api-client.sh
 */

export * from './schema';
export * from './client';
EOF

    log_info "Generated: $OUTPUT_DIR/index.ts"
}

# Main execution
main() {
    log_info "Starting API client generation..."

    # Verify OpenAPI spec exists
    if [[ ! -f "$SPECS_DIR/openapi.yaml" ]]; then
        log_error "OpenAPI spec not found at $SPECS_DIR/openapi.yaml"
        exit 1
    fi

    check_dependencies
    generate_types
    generate_client
    generate_index

    log_info "API client generation complete!"
    log_info "Generated files:"
    log_info "  - $OUTPUT_DIR/schema.ts (types)"
    log_info "  - $OUTPUT_DIR/client.ts (typed client)"
    log_info "  - $OUTPUT_DIR/index.ts (exports)"

    echo ""
    log_info "Usage example:"
    echo "  import { initializeApiClient, getApiClient } from '@/lib/api/generated';"
    echo ""
    echo "  // Initialize once at app startup"
    echo "  initializeApiClient({"
    echo "    baseUrl: 'http://localhost:8000',"
    echo "    getAccessToken: () => localStorage.getItem('accessToken'),"
    echo "    onUnauthorized: () => { /* handle 401 */ },"
    echo "  });"
    echo ""
    echo "  // Use anywhere"
    echo "  const api = getApiClient();"
    echo "  const { data, error } = await api.auth.login({ email, password });"
}

main "$@"
